<!-- c038bdb1-25b8-4cf2-9203-9198c8edab1c -->
---
layout: post
comments: true
title: 2024-03-21
categories: [crypto]
---

[í”„ë¡œì íŠ¸ 100ë§Œì›] ìë™ë§¤ë§¤ë¡œ 100ë§Œì›ìœ¼ë¡œ 926ë‹¬ëŸ¬ ë§Œë“¤ê¸°

```javascript
  "current_evaluated_asset": 867.978018632,
  "max_asset": 926.8676602304,
  "min_asset": 728.7634088696,
```

ì–¼ë§ˆë‚˜ ë²Œì—ˆë‚˜

ë§¤ë§¤ ì•Œê³ ë¦¬ì¦˜

íˆ¬ì ì›ì¹™

ë§¤ë§¤ë´‡ ì½”ë“œ

ì•ìœ¼ë¡œ..





usdt ê¸°ì¤€ 749 â†’ 927 (+23.8%) â†’ 868 (+15.9%)

100ë§Œ ì› â†’ 123ë§Œì›ì›



ê°€ë§Œíˆ ì•‰ì•„ì„œ ë¹„íŠ¸ì½”ì¸ìœ¼ë¡œ 23ë§Œì›ì„ ë²Œì—ˆë‹¤. 

ë¹„íŠ¸ì½”ì¸ ìë™ë§¤ë§¤ ë´‡ì„ ë§Œë“¤ì–´ ê°€ë§Œíˆ ëƒ…ë’€ë”ë‹ˆ ì•Œì•„ì„œ ëˆì„ ë²Œì–´ë‹¤ ì£¼ë”ë¼. ì´ ê¸€ì€ ìë™ë§¤ë§¤ ë´‡ì— ëŒ€í•œ ì „ë°˜ì ì¸ ë‚´ìš©ì— ëŒ€í•´ ë‹´ì•˜ë‹¤. ì¶”í›„ì—ëŠ” ìë™ë§¤ë§¤ ë´‡ì„ ì„¸íŒ…í•˜ê¸° ìœ„í•œ ì‚¬ì „ ì¤€ë¹„ì‘ì—…(link), ìë™ë§¤ë§¤ ë´‡ì„ í†µí•œ ìˆ˜ìµ ì‹¤í˜„ í›„ê¸°(link) ë“±ì— ëŒ€í•´ ë‹¤ë£¨ê³ ì í•œë‹¤.



<div style="color: default; border-left: 4px solid blue; padding-left: 15px;">
â— ì•”í˜¸í™”íëŠ” ë³€ë™ì„±ì´ í¬ë‹¤. íŠ¹ì • êµ¬ê°„ì„ íš¡ë³´í•œë‹¤ë©´ ìŒ€ ë•Œ ì‚¬ì„œ ë¹„ìŒ€ ë•Œ ì‚¬ëŠ” ê²ƒì„ ë°˜ë³µí•œë‹¤ë©´, ì´ íš¡ë³´í•˜ëŠ” ì‹œì¥ì—ì„œ ì ì í•œ ì´ë“ì„ ë³¼ ìˆ˜ ìˆì§€ ì•Šì„ê¹Œ! â—
</div>    




ê°€ì¥ í° ì•„ì´ë””ì–´ëŠ” ì´ê±°ì˜€ë‹¤. íš¡ë³´í•˜ëŠ” ì‹œì¥ì—ì„œì˜ ì´ë“. ì´ë¥¼ ì‹¤í˜„í•˜ê¸° ìœ„í•´ì„œëŠ” ì ì€ ë¹„ì¤‘ìœ¼ë¡œ ë“¤ì–´ê°€ì„œ, ê°€ê²©ì´ ë‚´ë ¤ê°€ë©´ ë” ì‚¬ê³ , ì˜¬ë¼ê°€ë©´ íŒ”ê¸°ë§Œ í•˜ë©´ ëœë‹¤.



ì´ ì•„ì´ë””ì–´ë¥¼ ë°±í…ŒìŠ¤íŒ…ê³¼ ì‹¤ì „ì˜ ì‹œí–‰ì°©ì˜¤ë¥¼ í†µí•´ ê·¸ëŸ´ì‹¸í•œ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ë§Œë“¤ì–´ëƒˆê³ ,

2023ë…„ ë§ì— ì‹œì‘í•´ 2024ë…„ ì´ˆì¸ ì§€ê¸ˆê¹Œì§€ 16%ì˜ ìˆ˜ìµë¥ ì„ ë³´ì´ê³  ìˆë‹¤. 



ë”± 100ë§Œì›ë§Œ íˆ¬ìí•´ ë§¤ë§¤ë´‡ì„ ìš´ì˜í•˜ê¸°ë¡œ í–ˆëŠ”ë°, ìœ ì§€ë³´ìˆ˜ ê¸°ê°„ì„ ì œì™¸í•˜ê³  ì´ 1,460ì‹œê°„ë™ì•ˆ ë§¤ë§¤ë´‡ì´ ì—´ì‹¬íˆ ì¼í•œ ê²°ê³¼, ìì‚°ê°€ì¹˜ê°€ ìµœëŒ€ 927ë‹¬ëŸ¬ì— ë‹¬í•´ ìˆ˜ìµë¥  23.8%ì— ìœ¡ë°•í•œ ì ë„ ìˆì—ˆê³ , ëˆì„ ìƒì–´ 729ë‹¬ëŸ¬ì˜ ê°€ì¹˜ì¸ 2.7% ì†ì‹¤ì´ ë‚œì ë„ ìˆì—ˆë‹¤. 3ì›” 21ì¼ í˜„ì¬ëŠ” ìˆ˜ìµë¥  16%ì„ ê¸°ë¡í•˜ê³  ìˆë‹¤.



í˜„ì¬ ë§¤ë§¤ë´‡ì—ê²Œ ë¶ˆë¦¬í•œ í•˜ë½ì¥ì´ë¼ ì†ì‹¤ì„ ê°ìˆ˜í•˜ê³  ìˆì§€ë§Œ, ì‹œì¥ì˜ ë³€ë™ì„±ì´ ì»¤ì§€ë©´ ë‹¤ì‹œ ìˆ˜ìµì„ ë†’ì—¬ê°€ë¦¬ë¼ ìƒê°í•œë‹¤. 



### ê·¸ë˜ì„œ ë‚´ ì•Œê³ ë¦¬ì¦˜ì´ ë„ëŒ€ì²´ ë¬´ì—‡ì¸ê°€?



> ë‚´ ì§€ê°‘ê³¼ ë¹„íŠ¸ì½”ì¸ì˜ ê°€ê²©ë§Œ ë³´ê³  ì‚´ì§€ ë§ì§€ íŒë‹¨í•œë‹¤. ìš°ì„  íˆ¬ìê¸ˆì˜ 50ë¶„ì˜ 1 ë§Œí¼ êµ¬ë§¤í•œë‹¤. ê·¸ë¦¬ê³ ë‚˜ì„œ ë‚´ í‰ë‹¨ê°€ì™€ ë¹„êµí•´, 0.5% (target loss)ë¯¸ë§Œìœ¼ë¡œ ê°€ê²©ì´ ë–¨ì–´ì§€ë©´ ë¬¼íƒ€ê¸°ë¥¼ í•˜ëŠ”ë°, ì´ì „ì— êµ¬ë§¤í•˜ë˜ ë‹¨ìœ„ì˜ 2ë°°ë¥¼ êµ¬ë§¤í•œë‹¤. ë‚´ í‰ë‹¨ê°€ì™€ í˜„ì¬ ê°€ê²©ì„ ê³„ì† ë¹„êµí•˜ë©° 0.5% ë¯¸ë§Œìœ¼ë¡œ ë–¨ì–´ì§€ë©´ 2ë°° ë¬¼íƒ€ê¸°ë¥¼ ê³„ì† ì§„í–‰í•´ í‰ë‹¨ê°€ë¥¼ ë‚®ì¶”ë©° ì½”ì¸ ë¹„ì¤‘ì„ ë†’ì´ëŠ” ê²ƒì´ë‹¤. ê·¸ë¦¬ê³  ê°€ê²©ì´ ìƒìŠ¹í•´ 3%(target profit)ì´ìƒìœ¼ë¡œ ê°€ê²©ì´ ìƒìŠ¹í•˜ë©´ ì „ë¶€ ë§¤ë„í•˜ì—¬ ìˆ˜ìµì„ ì‹¤í˜„í•œë‹¤. ê·¸ë¦¬ê³  ë‹¤ì‹œ íˆ¬ìê¸ˆì˜ 50ë¶„ì˜ 1ë§Œí¼ êµ¬ë§¤í•˜ì—¬ íˆ¬ìë¥¼ ê³„ì† ì´ì–´ë‚˜ê°„ë‹¤.



â€œë¬´ì§€ì„± ë¬¼íƒ€ê¸°â€ ë§¤ë§¤ë²•ì´ë‹¤. í•˜ì§€ë§Œ ì´ë§Œí•œ ë§¤ë§¤ë²•ë„ ì—†ëŠ” ê²ƒ ê°™ë‹¤. ë‹¤ì–‘í•œ ì§€í‘œë¥¼ í™•ì¸í•˜ë©° ë¨¸ë¦¬ì•„í”„ê²Œ ê³ ë¯¼í•˜ì§€ ë§ê³  ë‹¨ìˆœí•˜ê²Œ ë‚´ ì§€ê°‘, í‰ë‹¨ê°€, í˜„ì¬ê°€ê²©ë§Œ ê°€ì§€ê³  ë§¤ë§¤ë¥¼ ê²°ì •í•˜ëŠ” ê²ƒì´ë‹¤.

ë¯¸ë˜ëŠ” ì•Œ ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— ë¬¼íƒ€ê¸°ë¥¼ í†µí•´ íš¡ë³´í•˜ëŠ” ì¥ì—ì„œ ë°‘ì—ì„œ ì‚¬ê³  ìœ„ì—ì„œ íŒ”ê² ë‹¤ëŠ” ê²ƒì´ë‹¤. ê°€ê²©ì´ ë†’ìœ¼ë©´ ë¹„ì¤‘ì„ ì¤„ì´ê³ , ê°€ê²©ì´ ë¹„ì‹¸ë©´ ë¹„ì¤‘ì„ ë†’ì¸ë‹¤ëŠ” ì›ì¹™ ì•„ë˜ ì˜ ë™ì‘í•œë‹¤. 



### ì›ì¹™.. ì›ì¹™ì´ ìˆì—ˆì–´?

ë‹¹ì—°íˆ ì›ì¹™ì€ ì„¸ì›Œë‘ê³  ì§„í–‰í–ˆë‹¤.

ìš°ì„  ì•”í˜¸í™”í ê±°ë˜ ìì²´ì— ê´€ì‹¬ì´ ì—†ë‹¤ê°€ ê°œë°œ í”„ë¡œì íŠ¸ì˜ ì¼í™˜ìœ¼ë¡œ ê²½í—˜í•´ë³¸ë‹¤ëŠ” ì·¨ì§€ë¡œ ê°€ë³ê²Œ ì ‘ê·¼í–ˆë‹¤. ë•Œë¬¸ì— 1. ë¶€ë‹´ê°€ì§€ ì•ŠëŠ” ì„ ì—ì„œ ë‚´ ëˆì„ ì“°ê¸°ë¡œ í–ˆë‹¤. íˆ¬ìê¸ˆ 100ë§Œì›ì€ ì´ë ‡ê²Œ ê²°ì •ëë‹¤.

2. ë‚´ ì¼ìƒì— ì˜í–¥ì„ ì£¼ë©´ ì•ˆëœë‹¤. ì´ê±´ ì§€í‚¤ê¸° ì–´ë µê¸´ í•˜ì§€ë§Œ, ë‚´ í˜„ìƒì´ ë°”ì˜ë“  ë°”ì˜ì§€ ì•Šë“  ë§¤ë§¤ë´‡ì€ ì–¸ì œë‚˜ ì—´ì‹¬íˆ ì¼í•œë‹¤. 24ì‹œê°„ ë‚´ë‚´ 10ë¶„ë§ˆë‹¤ ê°€ê²©ì°½ì„ ë“¤ì—¬ë‹¤ë³´ê³  ì •í•´ì§„ ë°©ë²•ì— ë”°ë¼ ë§¤ë§¤ë¥¼ ì§„í–‰í•˜ê¸° ë•Œë¬¸ì— ë‚´ê°€ ì‹ ê²½ì“°ì§€ ì•Šì•„ë„ ëˆì„ ë²Œê³  ìˆë‹¤. í•˜ì§€ë§Œ ê¶ê¸ˆí•˜ê¸°ë„ í•˜ê³  ë¹„íŠ¸ì½”ì¸ ë‰´ìŠ¤ê°€ ë“¤ë¦¬ë©´ ìì—°ìŠ¤ë ˆ ì„œë²„ì— ì ‘ì†í•˜ì—¬ í™•ì¸í•˜ë©´ì„œ ë‚´ ì‹œê°„ì„ ì¡ì•„ë¨¹ê³  ìˆë‹¤ğŸ˜‚Â ê·¼ë° ëœ¬ê¸ˆì—†ì´ ì ‘ì†í•´ì„œ í™•ì¸í•˜ë©´ì„œ ì—¬ëŸ¬ ë²„ê·¸ë¥¼ í™•ì¸í•œ ì ë„ ìˆë‹¤. ì„œë²„ì— ì ‘ì†í•˜ì§€ ì•Šì•„ë„ ì˜ ëŒì•„ê°€ê³  ìˆëŠ”ì§€ ì—¬ë¶€ë¥¼ í™•ì¸í•  ìˆ˜ ìˆê²Œ ëª¨ë°”ì¼ ë©”ì‹ ì €ì™€ ì—°ë™í•´ ë†”ì„œ ì‰½ê²Œ ì²´í¬í•  ìˆ˜ ìˆë‹¤.



ëŒ€ì›ì¹™ ì•„ë˜ ì—¬ëŸ¬ íˆ¬ì ì„±í–¥ê³¼ íˆ¬ì ë°©ì‹ì„ ì¡°í•©í•´ ì§€ê¸ˆì˜ ì•Œê³ ë¦¬ì¦˜ì„ ì¡°í•©í–ˆë‹¤. ì—¬ëŸ¬ ì¬ë°ŒëŠ” ì´ì•¼ê¸°ëŠ” ë‹¤ë¥¸ ê¸€ì—ì„œ ì°¨ì°¨ í’€ê¸°ë¡œ í•˜ê³  ê·¸ë˜ì„œ ë§¤ë§¤ë´‡ ì½”ë“œ ì–´ë–»ê²Œ ìƒê²¨ë¨¹ì—ˆë‹ˆ?



ë©”ì¸ì½”ë“œ run.py , ì •ë³´ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ìˆëŠ” ë§¤ë§¤ë´‡ ë©”ëª¨ì¥ info.json, ì•”í˜¸í™”í ê±°ë˜ì†Œ ì¸ì¦í‚¤ë¥¼ ë‹´ì€ api.txt , slack ë©”ì‹ ì € í† í°ì„ ë‹´ì€ BotUserOAuthToken.txt ì´ í•„ìš”í•˜ë‹¤.



run.py 

```python
import ccxt
import datetime
import time
import json
from pydantic import BaseModel, PrivateAttr
from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError
with open("BotUserOAuthToken.txt") as f:
        lines = f.readlines()
        slack_token = lines[0].strip() 
        alert_channel = lines[1].strip()
        general_channel = lines[2].strip()

def open_binance():
    # íŒŒì¼ë¡œë¶€í„° apiKey, Secret ì½ê¸° 
    with open("api.txt") as f:
        lines = f.readlines()
        api_key = lines[0].strip() 
        api_secret = lines[1].strip() 

    return ccxt.binance(config={
        'apiKey': api_key,
        'secret': api_secret,
        'enableRateLimit': True,
        'rateLimit': 250,
        'options': {
            'adjustForTimeDifference': True,
        },
        'timeout':30000,
    })

class autoTrade (BaseModel):
    fee : float  
    buy_count : int 
    sell_count : int 

    usdt_balance : dict
    btc_balance :dict

    average_price : float
    now_price : float
    target_price : float 
    target_profit : float 
    limit_loss : float

    div : int 
    r : int
    timeframe : str  #TODO
    amount_ratio : float 

    current_evaluated_asset : float 
    max_asset : float 
    min_asset : float 

    running_days : int 
    running_hours : int
    total_running_hours: int 
    buying_streaks_count : int
    buying_streaks_count_max : int
    execute_start_str : str
    btc_amount : float
    usdt_amount : float


    _bot : WebClient = PrivateAttr()
    _binance : PrivateAttr()
    _execute_start : PrivateAttr()
    _amount : float
    def __init__(self, binance, bot, **kwargs):
        super().__init__(**kwargs)

        self._bot = bot
        self._binance = binance
        self.usdt_balance = self._binance.fetch_balance()['USDT']
        self.btc_balance = self._binance.fetch_balance()['BTC']
        self.average_price = self._get_average_price()
        self._execute_start = datetime.datetime.strptime(self.execute_start_str, '%Y-%m-%d %H:%M:%S.%f')
        self.running_days = 0
        self.running_hours = 0
        self._amount = (self.btc_balance['total'] + self.usdt_balance['total']/self.average_price)/self.div
        print('so far so good')

    def update(self):
        with open('info.json') as f:
            data = json.load(f)
        self.fee = data['fee']
        self.buy_count = max(self.buy_count, data['buy_count'])
        self.sell_count =  max(self.sell_count, data['sell_count'])

        wallet = self._binance.fetch_balance()
        self.usdt_balance = wallet['USDT']
        self.btc_balance = wallet['BTC']

        self.average_price = self._get_average_price()
        self.target_profit = data['target_profit']
        self.limit_loss = data['limit_loss']

        self.div = data['div']
        # self.r = data['r']
        self.timeframe = data['timeframe']
        self.amount_ratio = data['amount_ratio']
        self.usdt_amount = round(self._amount * self._binance.fetch_ticker("BTC/USDT")['ask'],2)
        self.btc_amount = round(self._amount,7)

        self.buying_streaks_count_max = data['buying_streaks_count_max']

        with open('info.json', 'w') as f:
            f.write(self.model_dump_json(indent=2))

    def _get_average_price(self):
        orders = self._binance.fetch_my_trades('BTC/USDT')
        total_amount=0
        average=0
        for i, o in enumerate(orders):
            if o['side'] == 'buy':
                average = (average * total_amount + o['cost'])/(total_amount+o['amount']) if total_amount + o['amount'] != 0 else 0
                total_amount += o['amount']
            elif o['side'] == 'sell':
                # total_amount-=o['amount']
                total_amount=0
        self.target_price = round(average * (1 + self.target_profit),2)
        return average

    def alert(self, txt):
        try:
            res = self._bot.chat_postMessage(
                channel=alert_channel,
                text=txt
            )
        except SlackApiError as e:
            assert e.res['error']

    def message(self, txt):
        try:
            res = self._bot.chat_postMessage(
                channel=general_channel,
                text=txt
            )
        except SlackApiError as e:
            assert e.res['error']

    def buy_coin(self, amount, price, symbol="BTC/USDT"):
        order = None
        try:
            if amount <0.00001:
                print('you should BUY at least 0.00001 BTC')
                wallet = self._binance.fetch_balance()
                print(f"now in your usdt wallet : {wallet['USDT']}")
                print(f"now in your btc wallet : {wallet['BTC']}")
                print()

            if self._binance.fetch_balance()['USDT']['free'] >= amount * price *(1+self.fee):
                # order = self._binance.create_limit_buy_order(symbol=symbol, amount=amount, price=price*1.005) #0.5% ë¹„ì‹¸ê²Œ êµ¬ë§¤. 
                order = self._binance.create_market_buy_order(symbol=symbol, amount=amount) #ì‹œì¥ê°€ ë§¤ìˆ˜? ëˆì—†ì–´ì„œ ê±°ë˜ê°€ ì•ˆë˜ë‚˜ë´„
                self.average_price = self._get_average_price()
                print(f'buying...average buy price : {self.average_price}')
                self.buy_count += 1
                self.r *= 2
            else:
                print(f"you don't have enough USDT to buy {amount} BTC")
        except Exception as e:
            print(e)
            print(f'Error happened buying coins {datetime.datetime.now()}')
            print(f'usdt wallet : {self.usdt_balance} | btc wallet : {self.btc_balance}')
            print(f'amount : {amount} price: {price}')
            self.alert(f'Error happened buying coins {datetime.datetime.now()}')
        return order if order is not None else -1

    def sell_coin(self, amount, price, symbol="BTC/USDT"):
        order = None
        try:
            if amount <0.00001:
                print('you should SELL at least 0.00001 BTC')
                print(f'atm in your usdt wallet : {self.usdt_balance}')
                print(f'atm in your btc wallet : {self.btc_balance}')
                print()

            # order = self._binance.create_limit_buy_order(symbol=symbol, amount=amount, price=price*1.005) #0.5% ì‹¸ê²Œ íŒë§¤
            order = self._binance.create_market_sell_order(symbol=symbol, amount=amount) #ì‹œì¥ê°€ ë§¤ë„
            self.sell_count += 1
            self.r = 1

        except Exception as e:
            print(e)
            print(f'Error happened selling coins {datetime.datetime.now()}')
            print(f'usdt wallet : {self.usdt_balance} | btc wallet : {self.btc_balance}')
            print(f'amount : {amount} btc price : {price}')
            self.alert(f'Error happened selling coins {datetime.datetime.now()}')
        return order if order is not None else -1

    def execute(self):
        i=0
        streaks_flag = True
        while True:
            cycle_start=datetime.datetime.now()

            self.update()

            price = self._binance.fetch_ticker("BTC/USDT")['ask']
            self.now_price = round(price,2)
            if self.btc_balance['total'] <= 0.00001:
                print(f'=====reset=====on {datetime.datetime.now()}')
                self.r=1
                print(f'{self.buy_count} buy and {self.sell_count} sell')
                self._amount=self.usdt_balance['free']/self.div/price
                self.buy_coin(amount=self._amount, price=price)
                # self.buy_coin(amount=self._usdt_balance['free']/self._div/price, price=price)
            
            if price >= self.average_price * (1+self.target_profit):
                self.sell_coin(amount=self.btc_balance["free"], price=price)# TODO
                print(f'=====sell=====on {datetime.datetime.now()}')

            if price <= self.average_price * (1-self.limit_loss) and i != 0 and self.buying_streaks_count < self.buying_streaks_count_max and streaks_flag:
                order = self.buy_coin(amount=self.r * self._amount,price=price)
                # self.buy_coin(amount=self._usdt_balance['free']/self._div/price,price=price)
                self.buying_streaks_count += 1
            else:
                streaks_flag = False
                self.buying_streaks_count -= 1
                self.buying_streaks_count = max(self.buying_streaks_count, 0)
                if self.buying_streaks_count == 0:
                    streaks_flag = True


            self.current_evaluated_asset = self.usdt_balance['free'] + self.btc_balance['free'] * price

            self.max_asset = max (self.max_asset, self.current_evaluated_asset)
            self.min_asset = min (self.min_asset, self.current_evaluated_asset)

            #7days info
            if datetime.datetime(self._execute_start.year, self._execute_start.month, self._execute_start.day) + datetime.timedelta(self.running_days+7) < datetime.datetime.now():
                print(f'@@@for 7days@@@')
                print(f'max asset : {self.max_asset}, min asset : {self.min_asset}')
                self.message(f'for 7days...')
                self.message(f'max asset : {self.max_asset}usdt, min asset : {self.min_asset} usdt')
                self.message(f'{self.buy_count} buy and {self.sell_count} sell for {i+1} cycles')
                self.message(f'btc wallet : {self.btc_balance}')
                self.message(f'usdt wallet : {self.usdt_balance}')

            # check integrity every midnight
            if datetime.datetime(self._execute_start.year, self._execute_start.month, self._execute_start.day) + datetime.timedelta(self.running_days) < datetime.datetime.now():
                self.running_days+=1
                print('new day')
                self.message(f'Have a Nice day! current asset : {self.current_evaluated_asset} usdt')

            # write logs every 6hour
            if datetime.datetime(self._execute_start.year, self._execute_start.month, self._execute_start.day, self._execute_start.hour, self._execute_start.minute, self._execute_start.second) + datetime.timedelta(hours=self.running_hours) < datetime.datetime.now():
                self.running_hours+=6
                self.total_running_hours+=6
                print(f'###status### {datetime.datetime.now()}')
                print(f'current asset : {self.current_evaluated_asset} usdt')
                print(f'btc wallet : {self.btc_balance}')
                print(f'usdt wallet : {self.usdt_balance}')
                self.message(f'###6-hour-status### {datetime.datetime.now()}')
                self.message(f'average buy price {self.average_price}')
                self.message(f'now price {self.now_price}')
                self.message(f'target price {self.target_price}')
                self.message(f'current asset : {self.current_evaluated_asset} usdt')
                self.message(f'usdt wallet : {self.usdt_balance}')
            


            
            if i==0:
                t=f'starting... current asset : {self.current_evaluated_asset} usdt'
                print(t)
                print(f'average buy price {self.average_price}')
                self.alert(t)
                self.alert(f'btc wallet : {self.btc_balance}')
                self.alert(f'usdt wallet : {self.usdt_balance}')
                self.message('starting...')
                self.message(f'average buy price {self.average_price}')
                self.message(f'now price {self.now_price}')
                self.message(f'target price {self.target_price}')
                self.message(f'current asset : {self.current_evaluated_asset} usdt')
                self.message(f'usdt wallet : {self.usdt_balance}')

            print(f'{i} cycle : {(datetime.datetime.now()-cycle_start).microseconds/1e6}s on {datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")}')

            i+=1
            for k in range(59):
                time.sleep(10)
                price = self._binance.fetch_ticker("BTC/USDT")['ask'] #it takes 0.1s
                if price < self.average_price * (1-self.limit_loss*1.5) or price > self.average_price * (1+self.target_profit*1.2):
                    break


def main():
    with open('info.json') as f:
        data = json.load(f)

    trader = autoTrade(binance=open_binance(), bot=WebClient(token=slack_token), **data)
    trader.execute()

if __name__ == '__main__':
    main()
```

info.json

```json
{
  "fee": 0.001,
  "buy_count": 246,
  "sell_count": 31,
  "usdt_balance": {
    "free": 559.75447497,
    "used": 0.0,
    "total": 559.75447497
  },
  "btc_balance": {
    "free": 0.00462256,
    "used": 0.0,
    "total": 0.00462256
  },
  "average_price": 66667.68831168831,
  "now_price": 67010.01,
  "target_price": 68667.72,
  "target_profit": 0.03,
  "limit_loss": 0.005,
  "div": 50,
  "r": 8,
  "timeframe": "50m",
  "amount_ratio": 0.0,
  "current_evaluated_asset": 869.5122667956,
  "max_asset": 926.8676602304,
  "min_asset": 728.7634088696,
  "running_days": 1,
  "running_hours": 6,
  "total_running_hours": 1460,
  "buying_streaks_count": 0,
  "buying_streaks_count_max": 2,
  "execute_start_str": "2024-03-21 13:48:00.452492",
  "btc_amount": 0.0002604,
  "usdt_amount": 17.43
}
```

ì´ë ‡ê²Œ ì½”ë“œì™€ ë‚´ìš©ì„ í†µí•´ ì‹¤í–‰í•  ìˆ˜ ìˆê³ , api í‚¤ ë“± êµ¬ì²´ì ì¸ ì…‹ì—… ë°©ë²•ì€ ì¶”í›„ ê¸€ì„ í†µí•´ ê³µê°œí•˜ê² ë‹¤.

